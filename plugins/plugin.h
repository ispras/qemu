/*
 * Copyright (C) 2015 ISP RAS
 */

#ifndef PLUGIN_H
#define PLUGIN_H

#include "qemu-common.h"
#include "qom/cpu.h"
#include "monitor/monitor.h"

#include "uthash.h" /* Hash realisation with *char keys */

//#ifndef TCG_TARGET_REG_BITS
#include "tcg/tcg.h"
//#endif

#if TARGET_LONG_BITS == 32
#define MAKE_TCGV MAKE_TCGV_I32
#else
#define MAKE_TCGV MAKE_TCGV_I64
#endif

/* IDs of signals generated by QEMU core */

// Commented items are not used yet
/*enum {
    PLUGIN_QEMU_BEFORE_GEN_TB,
    PLUGIN_QEMU_INSTR_TRANSLATE,
    PLUGIN_QEMU_EXCEPTION,
    PLUGIN_QEMU_EXCEPTION_HANDLER,
    PLUGIN_QEMU_INSTRUCTION_EXCEPTION,
    PLUGIN_QEMU_INTERRUPT,
    PLUGIN_QEMU_TLB_SET_PAGE,
    PLUGIN_QEMU_CPU_PAUSED,
    PLUGIN_QEMU_PAGE_DIR_UPD,
    PLUGIN_QEMU_CPUS_STOPPED
};*/

typedef struct ContextList{
    target_ulong context;
    struct ContextList *next;
} ContextList;

/* Parameters for instr translate event */
struct PluginParamsInstrTranslate
{
    target_ulong pc;
    struct TranslationBlock *tb;
};

/* Parameters for tlb add page event */
struct PluginParamsTlbAddPage
{
    target_ulong vaddr;
    hwaddr paddr;
    int prot;
    int mmu_idx;
    target_ulong size;
};

struct pi_info {
    const char **signals_list; //list of signals, that are provided by this plugin
    const char **dependencies; //list of plugins, that should be loaded to provide correct work for this plugin
    const char **os_ver; //self explanatory
    //available functions
};

#ifdef CONFIG_PLUGIN
    void plugins_set_os(const char *os_ver);
    void plugins_init(void);
    uint64_t get_current_context(void);
    void set_current_ctxt(target_ulong ctxt);

    bool plugin_load(const char *name);
    void plugins_load(const char *name);
    bool plugin_unload(const char *name);
    void plugin_list(Monitor *mon);

    void plugin_exception(CPUState *cpu);
    void plugin_instruction_exception(CPUState *cpu);
    void plugin_exception_handler(CPUState *cpu);
    void plugin_interrupt(CPUState *cpu);
    void plugin_tlb_set_page(CPUState *cpu, target_ulong vaddr,
                             hwaddr paddr, int prot, int mmu_idx, target_ulong size);
    void plugin_cpus_stopped(void);
    void plugin_cpu_paused(CPUState *cpu);
    void plugin_exit(void);
    void plugin_page_dir_update(CPUArchState *env, target_ulong context);
    void plugin_ld(CPUArchState *env, target_ulong vaddr, target_ulong size, uint64_t val);
    void plugin_st(CPUArchState *env, target_ulong vaddr, target_ulong size, uint64_t val);
    void plugin_instr_translate(target_ulong pc, CPUState *cpu, struct TranslationBlock *tb);
    void plugin_before_gen_tb(CPUState *cpu, struct TranslationBlock *tb);
    const char *plugin_get_filename(void);
    void plugin_gen_ld32(TCGContext *ctx, TCGMemOp memop, TCGv addr, TCGArg idx, TCGv_i32 val);
    void plugin_gen_st32(TCGContext *ctx, TCGMemOp memop, TCGv addr, TCGArg idx, TCGv_i32 val);
    void plugin_gen_ld64(TCGContext *ctx, TCGMemOp memop, TCGv addr, TCGArg idx, TCGv_i64 val);
    void plugin_gen_st64(TCGContext *ctx, TCGMemOp memop, TCGv addr, TCGArg idx, TCGv_i64 val);
    
#else
#   define plugins_set_os(str)
#   define plugins_init()
#   define get_current_context() 0
#   define set_current_ctxt(ctxt)

#   define plugin_load(dso) false
#   define plugins_load(dso) false
#   define plugin_unload(dso) false
#   define plugin_list(mon)

#   define plugin_exception(env)
#   define plugin_instruction_exception(env)
#   define plugin_exception_handler(env)
#   define plugin_interrupt(env)
#   define plugin_tlb_set_page(cpu, vaddr, paddr, prot, mmu_idx, size)

#   define plugin_cpus_stopped()
#   define plugin_cpu_paused(cpu)
#   define plugin_exit()
#   define plugin_page_dir_update(env, ctxt)
#   define plugin_ld(env, vaddr, size, val)
#   define plugin_st(env, vaddr, size, val)
#   define plugin_instr_translate(pc, cpu, tb)
#   define plugin_before_gen_tb(cpu, tb)
#   define plugin_get_filename() "<unknown>"
#   define plugin_gen_ld32(ctx, memop, addr, idx, val)
#   define plugin_gen_st32(ctx, memop, addr, idx, val)
#   define plugin_gen_ld64(ctx, memop, addr, idx, val)
#   define plugin_gen_st64(ctx, memop, addr, idx, val)
#endif /* !CONFIG_PLUGIN */


struct PluginInterface;
typedef struct PluginInterface PluginInterface;

typedef void (* pi_cpus_stopped_t)(const PluginInterface *pi);
typedef void (* pi_exit_t)(const PluginInterface *pi);

void    plugin_register_syscall_callback(void *func, int name);
void    plugin_call_syscall_cb(CPUArchState *env);

const   mon_cmd_t *plugin_parse_command(Monitor *mon, const char **cmdline);
void    plugin_help_cmd_dump(Monitor *mon, char **args, int nb_args, int arg_index);
void    plugin_find_completion_by_table(Monitor *mon, char **args, int nb_args);

#ifdef CONFIG_PLUGIN

typedef void (* func_cb)(void *data, CPUArchState *env);

typedef struct SignalInfo{
        char name[256];             /* string key */
        struct Subs_group *subs_group;

        UT_hash_handle hh;          /* makes this structure hashable */
} SignalInfo;

typedef struct Subs_group{
        char str_id[256];             /* string key */
        struct Subscriber *subs;

        UT_hash_handle hh;          /* makes this structure hashable */
} Subs_group;

typedef struct Subscriber{
        func_cb callback;
        struct Subscriber *next;
} Subscriber;

typedef struct funcList{
        void *func;
        char name[256];

        struct funcList *next;
} funcList;

/* Register signal */
SignalInfo *plugin_reg_signal(const char *name);

/* Generating a signal with specific id for specific cb, with 'data' param 
    standing for programmer defined data, that would be transferred between 
    the eplugins */
void    plugin_gen_signal(SignalInfo *cb, const char* str_id, void *data, CPUArchState *env);

/* Returns list of the subscribers for the signal */
Subs_group *plugin_get_subscribers(SignalInfo *sig, const char *str_id);

/* Sends data to the specified list of the subscribers */
void    plugin_send_to_subscribers(Subs_group *sb_group, void *data, CPUArchState *env);

/* Checking if needed plugins were already loaded */
bool    plugin_check_loaded_signals(const char* signal_name);

/* Trying to find and load needed plugins */
bool    plugin_load_provider_plugin(const char* signal_name);

/* Registering additional subscriber. Should not be used in tpi_init. */
void    plugin_subscribe(void *func, const char *name, const char *str_id);

/* Deleting registered signal */
void    plugin_del_signal(SignalInfo *cb);

/* Deleting registered subscriber */
void    plugin_del_subscriber(void *func, const char *name, const char* str_id);

/* Getting list of fuctions that are available to call from plugin*/
const void *plugin_get_functions_list(const char *plugin_name);

const char *plugins_get_os(void);

#define PLUGIN_GEN_SIGNAL(cb, str_id, data, env)            \
    do {                                                    \
        if(cb){                                             \
            static Subs_group *subs;                        \
            if (!subs) {                                    \
                subs = plugin_get_subscribers(cb, str_id);  \
            }                                               \
            plugin_send_to_subscribers(subs, data, env);    \
        }                                                   \
    } while (0)

#endif

struct PluginParamsMemOp
{
    bool isLoad;
    uint64_t vaddr;
    //uint64_t paddr;
    uint64_t size;
    uint64_t value;
    //void* buf;
};

struct PluginInterface
{
    /* 'name' field to differ plugins from each other */
    char *name;
    /* List storing all the functions that are available
       for access from other plugins*/
    const void *funcs;

    /* Common parameters.  */
    const char **os_ver;
    FILE *output;

    const CPUState *cpu;
    const struct TranslationBlock *tb;

    mon_cmd_t *cmd_table;
    /*! Pointer to table with generated signal group names. */
    const char **signals;

    /* Plugin's callbacks.  */
    void (*unload_signal)(void);
    pi_cpus_stopped_t cpus_stopped;
    pi_exit_t exit;
};


/* Plugin exported functions */
typedef void (* pi_init_t)(PluginInterface *pi);
void pi_init(PluginInterface *pi);
void pi_start(PluginInterface *pi);

#endif /* PLUGIN_H */

